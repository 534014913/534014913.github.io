---
layout: post
title: "AtCoder ABC 050"
date: 2022-05-31 12:00:00 +0000
categories: [atcoder, abc]
---
- A: IO, primitive
- B: simulation, brute force.
- C: the question is daunting at first glance. It's clear after several minutes of consideration.
	- even case: N-1, N-3, N-5, ...3, 1, 1, 3, ..., N-5, N-3, N-1
	- odd case : N-1, N-3, N-5, ...2, 0, 2, ..., N-5, N-3, N-1
and only number with the same A values can be swapped, so thats (floor (N / 2)) pairs. Number of possible orders is expt(2, no. of pairs)
- D: for illustrative purposes, and is a bitwise logical AND, << is a left-shift operation, and >> is a right-shift operation. As a strategy, consider the digit DP that determines the bits of a and b from the top. As long as u = a xor b, 0 <= u always holds. also, v = a + b = ((a and b) << 1) + (a xor b) = ((a and b) << 1) + u, thus v >= u. so you only need to pay attention to the condition v <= N.
Consider the following DP:
	dp[i][j] = the numebr of ways in which the i-bits of a and b are determined and v
= j at that stage. This DP has tree possible transitions:
	- If the i-bit of a and the i-bit of b are both 1.
	- If the i-bit of a and the i-bit of b are both 0.
	- If only one of the i-bit of a or the i-bit of b is 1.
However, if this situation continues, this DP will become O(Nlog(N)) and will not be able to make it in time. So, let's modify this DP a bit and do the following. 
dp[i][j] = a number such that the i-bits of a and b are determined, at which point 
(v >> i) = (N >> i) - j.
At first glance, this just seems to be more complicated than before, but it doesn't seem to have improved the amount of computation. However, the the turn of j >= 2 does not cause v to excedd N, no matter how you subsequently select bits a and b. So it would be better to treat all of these patterns as j = 2.
Thus, the range of j only needs to be considered as 0 ~ 2, and this DP can now be done with O(logN).